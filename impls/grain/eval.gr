module Eval

include "./reader"
include "./types"
include "immutablemap"
include "list"
include "map"
include "option"
include "result"
include "string"
include "sys/file"

let rec quasiquote = (ast) => {
  match (ast) {
    Types.List([Types.Symbol("unquote"), ast]) => ast,
    Types.List(ast) => {
      let mut result = Types.List([])
      List.forEach((elt) => {
        match (elt) {
          Types.List([Types.Symbol("splice-unquote"), rest]) => {
            result = Types.List([Types.Symbol("concat"), rest, result])
          },
          _ => {
            result = Types.List([Types.Symbol("cons"), quasiquote(elt), result])
          },
        }
      }, List.reverse(ast))
      result
    },
    Types.Symbol(_) => Types.List([Types.Symbol("quote"), ast]),
    Types.HashMap(_) => Types.List([Types.Symbol("quote"), ast]),
    _ => ast,
  }
}

provide let rec eval = (ast, env) => {
  Result.flatMap((ast) => eval_inner(ast, env), macroexpand(ast, env))
},

eval_inner = (ast, env) => {
  match (ast) {
    Types.List([]) => Ok(ast),
    Types.List([Types.Symbol("quote"), ast]) => Ok(ast),
    Types.List([Types.Symbol("quasiquote"), ast]) => eval(quasiquote(ast), env),
    Types.List([Types.Symbol("do"), ...elems]) => {
      match (eval_list(elems, env)) {
        Err(err) => Err(err),
        Ok(evaluated) => {
          let last = List.length(evaluated) - 1
          let last = List.nth(last, evaluated)
          let last = Option.unwrapWithDefault(Types.Nil, last)
          Ok(last)
        }
      }
    },
    Types.List([Types.Symbol("if"), cond, then_ast]) => {
      match (eval(cond, env)) {
        Err(err) => Err(err),
        Ok(Types.Bool(false)) => Ok(Types.Nil),
        Ok(Types.Nil) => Ok(Types.Nil),
        Ok(_) => eval(then_ast, env),
      }
    },
    Types.List([Types.Symbol("if"), cond, then_ast, else_ast]) => {
      match (eval(cond, env)) {
        Err(err) => Err(err),
        Ok(Types.Bool(false)) => eval(else_ast, env),
        Ok(Types.Nil) => eval(else_ast, env),
        Ok(_) => eval(then_ast, env),
      }
    },
    Types.List([Types.Symbol("fn*"), Types.List(binds), body]) => eval_fn(binds, body, env),
    Types.List([Types.Symbol("fn*"), Types.Vector(binds), body]) => eval_fn(binds, body, env),
    Types.List([Types.Symbol("def!"), Types.Symbol(key), val]) => {
      Result.map((val) => Types.set(key, val, env), eval(val, env))
    },
    Types.List([Types.Symbol("defmacro!"), Types.Symbol(key), val]) => {
      let set_is_macro = (val) => {
        let val = match (val) {
          Types.Function(fn) => Types.Function({ cb: fn.cb, is_macro: true }),
          val => val,
        }

        Types.set(key, val, env)
      }

      Result.map(set_is_macro, eval(val, env))
    },
    Types.List([Types.Symbol("macroexpand"), ast]) => macroexpand(ast, env),
    Types.List([Types.Symbol("let*"), Types.List(bindings), body]) => {
      let inner = Types.make_inner(env)
      match (eval_let_bindings(bindings, inner)) {
        Some(err) => Err(err),
        None => eval(body, inner),
      }
    },
    Types.List([Types.Symbol("let*"), Types.Vector(bindings), body]) => {
      let inner = Types.make_inner(env)
      match (eval_let_bindings(bindings, inner)) {
        Some(err) => Err(err),
        None => eval(body, inner),
      }
    },
    Types.List([Types.Symbol("try*"), try_body, Types.List([Types.Symbol("catch*"), Types.Symbol(err_bind), catch_body])]) => {
      match (eval(try_body, env)) {
        Ok(val) => Ok(val),
        Err(err) when String.startsWith("error: ", err) => {
          let last = String.length(err)
          let err = String.slice(7, last, err)
          match (Reader.read_str(err)) {
            Ok(err) => {
              let env = Types.make_inner(env)
              Types.set(err_bind, err, env)
              eval(catch_body, env)
            },
            Err(err) => Err(err),
          }
        },
        Err(err) => {
          let env = Types.make_inner(env)
          Types.set(err_bind, Types.String(err), env)
          eval(catch_body, env)
        },
      }
    },
    Types.List(list) => {
      let evaluated = eval_list(list, env)
      Result.flatMap((list) => call_list(list, env), evaluated)
    },
    ast => eval_ast(ast, env)
  }
},

macroexpand = (ast, env) => {
  let mut ast = ast
  let mut err = None
  while (true) {
    match (ast) {
      Types.List([Types.Symbol(symbol), ...args]) =>
        match (Types.get_macro(symbol, env)) {
          Ok(fn) => match (fn.cb(args, env)) {
            Ok(new_ast) => ast = new_ast,
            Err(call_err) => { err = Some(call_err); break }, 
          },
          Err(_) => break,
        },
      _ => break,
    }
  }

  match (err) {
    Some(err) => Err(err),
    None => Ok(ast),
  }
},

eval_let_bindings = (bindings, env) => {
  let mut remaining = bindings
  let mut err = None
  while (true) {
    match (remaining) {
      [] => break,
      [Types.Symbol(key), val, ...tail] => {
        remaining = tail
        match (eval(val, env)) {
          Ok(val) => { let _ = Types.set(key, val, env) },
          Err(eval_err) => {
            err = Some(eval_err)
            break
          }
        }
      },
      _ => {
        err = Some("uneven let* bindings")
        break
      }
    }
  }

  err
},

call_list = (list, env) => {
  match (list) {
    [Types.Function(fn), ...args] => fn.cb(args, env),
    _ => Err("cannot call list"),
  }
},

eval_fn = (binds, body, env) => {
  let mut rest_binding = None
  let rec to_symbols = (list) => {
    match (list) {
      [] => Ok([]),
      [Types.Symbol("&"), Types.Symbol(rest)] => {
        rest_binding = Some(rest)
        Ok([])
      },
      [Types.Symbol(symbol), ...rest] => {
        Result.map((rest) => [symbol, ...rest], to_symbols(rest))
      },
      _ => Err("expected symbol or & and symbol"),
    }
  }

  match (to_symbols(binds)) {
    Err(err) => Err(err),
    Ok(binds) => {
      let cb = (args, env) => {
        let env: Types.Env = { outer: Some(env), data: Map.make() }
        let binds = List.zip(binds, args)
        List.forEach((arg) => {
          let (arg, bind) = arg
          let _ = Types.set(arg, bind, env)
        }, binds)

        match (rest_binding) {
          None => void,
          Some(rest_binding) => {
            let split_idx = List.length(binds)
            let (_binds, rest) = List.part(split_idx, args)
            let rest = Types.List(rest)
            Types.set(rest_binding, rest, env)
            void
          }
        }

        eval(body, env)
      }

      Ok(Types.Function({ cb, is_macro: false }))
    }
  }
},

eval_list = (list, env) => {
  match (list) {
    [] => Ok([]),
    [first, ...rest] => {
      match (eval(first, env)) {
        Err(err) => Err(err),
        Ok(evaluated) => {
          match (eval_list(rest, env)) {
            Err(err) => Err(err),
            Ok(rest) => Ok([evaluated, ...rest])
          }
        }
      }
    }
  }
},

eval_ast = (ast, env) => {
  match (ast) {
    Types.Symbol(sym) => Types.find(sym, env),
    Types.List(list) => {
      Result.map((list) => Types.List(list), eval_list(list, env))
    },
    Types.Vector(vec) => {
      Result.map((vec) => Types.Vector(vec), eval_list(vec, env))
    },
    Types.HashMap(map) => {
      let keys = ImmutableMap.keys(map)
      let vals = ImmutableMap.values(map)
      match (eval_list(vals, env)) {
        Err(err) => Err(err),
        Ok(evaluated) => {
          let entries = List.zip(keys, evaluated)
          Ok(Types.HashMap(ImmutableMap.fromList(entries)))
        }
      }
    },
    ast => Ok(ast),
  }
}
