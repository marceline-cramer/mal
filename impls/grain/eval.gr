module Eval

include "./reader"
include "./types"
include "immutablemap"
include "list"
include "map"
include "option"
include "result"
include "string"
include "sys/file"

let add = (lhs, rhs) => Types.Number(lhs + rhs)
let sub = (lhs, rhs) => Types.Number(lhs - rhs)
let mul = (lhs, rhs) => Types.Number(lhs * rhs)
let div = (lhs, rhs) => Types.Number(lhs / rhs)
let lt  = (lhs, rhs) => Types.Bool(lhs < rhs)
let le  = (lhs, rhs) => Types.Bool(lhs <= rhs)
let gt  = (lhs, rhs) => Types.Bool(lhs > rhs)
let ge  = (lhs, rhs) => Types.Bool(lhs >= rhs)

let wrap = (cb) => Types.Function({ cb, is_macro: false })

let wrap_op = (fn) => {
  let cb = (args, env) => {
    match (args) {
      [Types.Number(lhs), Types.Number(rhs)] => {
        Ok(fn(lhs, rhs))
      },
      _ => Err("expected two numbers"),
    }
  }

  wrap(cb)
}

let wrap_one = (fn) => {
  let cb = (ast, env) => {
    match (ast) {
      [val] => fn(val, env),
      _ => Err("expected one argument"),
    }
  }

  wrap(cb)
}

let wrap_two = (fn) => {
  let cb = (args, env) => {
    match (args) {
      [lhs, rhs] => fn(lhs, rhs, env),
      _ => Err("expected two arguments"),
    }
  }

  wrap(cb)
}

let wrap_list = (fn) => {
  let cb = (val, env) => {
    match (val) {
      Types.List(list) => fn(list, env),
      Types.Vector(list) => fn(list, env),
      Types.Nil => fn([], env),
      _ => Err("must be given a list"),
    }
  }

  wrap_one(cb)
}

let wrap_str = (fn) => {
  let cb = (val, env) => {
    match (val) {
      Types.String(str) => fn(str, env),
      _ => Err("must be given a string"),
    }
  }

  wrap_one(cb)
}

let list = (ast, env) => Ok(Types.List(ast))

let is_list = (val, env) => {
  let is_list = match (val) {
    Types.List(_) => true,
    _ => false,
  }

  Ok(Types.Bool(is_list))
}

let is_empty = (list, env) => Ok(Types.Bool(List.length(list) == 0))

let count = (list, env) => Ok(Types.Number(List.length(list)))

let pr_args = (args, print_readably, joiner) => {
  let strs = List.map((arg) => Types.pr_str(arg, print_readably), args)
  List.join(joiner, strs)
}

let puts = (str) => File.fdWrite(File.stdout, String.encode(str, String.UTF8))

let pr_str = (args, env) => Ok(Types.String(pr_args(args, true, " ")))

let str = (args, env) => Ok(Types.String(pr_args(args, false, "")))

let prn = (args, env) => {
  puts(pr_args(args, true, " ") ++ "\n")
  Ok(Types.Nil)
}

let println = (args, env) => {
  puts(pr_args(args, false, " ") ++ "\n")
  Ok(Types.Nil)
}

let eq = (args, env) => {
  // would include list_eq as part of the let binding but grain crashes
  let list_eq = (lhs, rhs, eq) => {
    if (List.length(lhs) != List.length(rhs)) {
      false
    } else {
      List.every(eq, List.zip(lhs, rhs))
    }
  }

  let rec eq = (args) => match (args) {
    (Types.Number(lhs), Types.Number(rhs)) => lhs == rhs,
    (Types.Bool(lhs), Types.Bool(rhs)) => lhs == rhs,
    (Types.String(lhs), Types.String(rhs)) => lhs == rhs,
    (Types.Keyword(lhs), Types.Keyword(rhs)) => lhs == rhs,
    (Types.Symbol(lhs), Types.Symbol(rhs)) => lhs == rhs,
    (Types.Nil, Types.Nil) => true,
    (Types.List(lhs), Types.List(rhs)) => list_eq(lhs, rhs, eq),
    (Types.List(lhs), Types.Vector(rhs)) => list_eq(lhs, rhs, eq),
    (Types.Vector(lhs), Types.List(rhs)) => list_eq(lhs, rhs, eq),
    (Types.Vector(lhs), Types.Vector(rhs)) => list_eq(lhs, rhs, eq),
    _ => false,
  }

  match (args) {
    [lhs, rhs] => Ok(Types.Bool(eq((lhs, rhs)))),
    _ => Err("invalid comparison")
  }
}

let read_string = (str, env) => {
  Reader.read_str(str)
}

let atom = (val, env) => Ok(Types.Atom(box(val)))

let is_atom = (val, env) => {
  let val = match (val) {
    Types.Atom(_) => true,
    _ => false,
  }

  Ok(Types.Bool(val))
}

let deref = (val, env) => {
  match (val) {
    Types.Atom(val) => Ok(unbox(val)),
    _ => Err("deref expects an atom"),
  }
}

let reset = (atom, val, env) => {
  match (atom) {
    Types.Atom(atom) => {
      atom := val
      Ok(val)
    },
    _ => Err("expected atom")
  }
}

let swap = (args, env) => {
  match (args) {
    [Types.Atom(atom), Types.Function(fn), ...args] => {
      let args = [unbox(atom), ...args]
      match (fn.cb(args, env)) {
        Err(err) => Err(err),
        Ok(val) => {
          atom := val
          Ok(val)
        },
      }
    },
    _ => Err("expected atom, function, and optional arguments"),
  }
}

let cons = (val, list, env) => {
  match (list) {
    Types.List(list) => Ok(Types.List([val, ...list])),
    Types.Vector(list) => Ok(Types.List([val, ...list])),
    _ => Err("expected list"),
  }
}

let concat = (args, env) => {
  let mut remaining = args
  let mut result = []
  let mut err = None

  while (true) {
    match (remaining) {
      [] => break,
      [Types.List(list), ...rest] => {
        result = List.append(result, list)
        remaining = rest
      },
      [Types.Vector(list), ...rest] => {
        result = List.append(result, list)
        remaining = rest
      },
      _ => {
        err = Some("expected list")
        break
      }
    }
  }

  match (err) {
    Some(err) => Err(err),
    None => Ok(Types.List(result)),
  }
}

let rec quasiquote = (ast) => {
  match (ast) {
    Types.List([Types.Symbol("unquote"), ast]) => ast,
    Types.List(ast) => {
      let mut result = Types.List([])
      List.forEach((elt) => {
        match (elt) {
          Types.List([Types.Symbol("splice-unquote"), rest]) => {
            result = Types.List([Types.Symbol("concat"), rest, result])
          },
          _ => {
            result = Types.List([Types.Symbol("cons"), quasiquote(elt), result])
          },
        }
      }, List.reverse(ast))
      result
    },
    Types.Symbol(_) => Types.List([Types.Symbol("quote"), ast]),
    _ => ast,
  }
}

provide let rec eval = (ast, env) => {
  match (ast) {
    Types.List([]) => Ok(ast),
    Types.List([Types.Symbol("quote"), ast]) => Ok(ast),
    Types.List([Types.Symbol("quasiquote"), ast]) => eval(quasiquote(ast), env),
    Types.List([Types.Symbol("do"), ...elems]) => {
      match (eval_list(elems, env)) {
        Err(err) => Err(err),
        Ok(evaluated) => {
          let last = List.length(evaluated) - 1
          let last = List.nth(last, evaluated)
          let last = Option.unwrapWithDefault(Types.Nil, last)
          Ok(last)
        }
      }
    },
    Types.List([Types.Symbol("if"), cond, then_ast]) => {
      match (eval(cond, env)) {
        Err(err) => Err(err),
        Ok(Types.Bool(false)) => Ok(Types.Nil),
        Ok(Types.Nil) => Ok(Types.Nil),
        Ok(_) => eval(then_ast, env),
      }
    },
    Types.List([Types.Symbol("if"), cond, then_ast, else_ast]) => {
      match (eval(cond, env)) {
        Err(err) => Err(err),
        Ok(Types.Bool(false)) => eval(else_ast, env),
        Ok(Types.Nil) => eval(else_ast, env),
        Ok(_) => eval(then_ast, env),
      }
    },
    Types.List([Types.Symbol("fn*"), Types.List(binds), body]) => {
      let mut rest_binding = None
      let rec to_symbols = (list) => {
        match (list) {
          [] => Ok([]),
          [Types.Symbol("&"), Types.Symbol(rest)] => {
            rest_binding = Some(rest)
            Ok([])
          },
          [Types.Symbol(symbol), ...rest] => {
            Result.map((rest) => [symbol, ...rest], to_symbols(rest))
          },
          _ => Err("expected symbol or & and symbol"),
        }
      }

      match (to_symbols(binds)) {
        Err(err) => Err(err),
        Ok(binds) => {
          let cb = (args, env) => {
            let env: Types.Env = { outer: Some(env), data: Map.make() }
            let binds = List.zip(binds, args)
            List.forEach((arg) => {
              let (arg, bind) = arg
              let _ = Types.set(arg, bind, env)
            }, binds)

            match (rest_binding) {
              None => void,
              Some(rest_binding) => {
                let split_idx = List.length(binds)
                let (_binds, rest) = List.part(split_idx, args)
                let rest = Types.List(rest)
                Types.set(rest_binding, rest, env)
                void
              }
            }

            eval(body, env)
          }

          Ok(wrap(cb))
        }
      }
    },
    Types.List([Types.Symbol("def!"), Types.Symbol(key), val]) => {
      Result.map((val) => Types.set(key, val, env), eval(val, env))
    },
    Types.List([Types.Symbol("let*"), Types.List(bindings), body]) => {
      let inner = Types.make_inner(env)
      match (eval_let_bindings(bindings, inner)) {
        Some(err) => Err(err),
        None => eval(body, inner),
      }
    },
    Types.List([Types.Symbol("let*"), Types.Vector(bindings), body]) => {
      let inner = Types.make_inner(env)
      match (eval_let_bindings(bindings, inner)) {
        Some(err) => Err(err),
        None => eval(body, inner),
      }
    },
    Types.List(list) => {
      let evaluated = eval_list(list, env)
      Result.flatMap((list) => call_list(list, env), evaluated)
    },
    ast => eval_ast(ast, env)
  }
},

eval_let_bindings = (bindings, env) => {
  let mut remaining = bindings
  let mut err = None
  while (true) {
    match (remaining) {
      [] => break,
      [Types.Symbol(key), val, ...tail] => {
        remaining = tail
        match (eval(val, env)) {
          Ok(val) => { let _ = Types.set(key, val, env) },
          Err(eval_err) => {
            err = Some(eval_err)
            break
          }
        }
      },
      [_] => {
        err = Some("uneven let* bindings")
        break
      }
    }
  }

  err
},

call_list = (list, env) => {
  match (list) {
    [Types.Function(fn), ...args] => fn.cb(args, env),
    _ => Err("cannot call list"),
  }
},

eval_list = (list, env) => {
  match (list) {
    [] => Ok([]),
    [first, ...rest] => {
      match (eval(first, env)) {
        Err(err) => Err(err),
        Ok(evaluated) => {
          match (eval_list(rest, env)) {
            Err(err) => Err(err),
            Ok(rest) => Ok([evaluated, ...rest])
          }
        }
      }
    }
  }
},

eval_ast = (ast, env) => {
  match (ast) {
    Types.Symbol(sym) => Types.find(sym, env),
    Types.List(list) => {
      Result.map((list) => Types.List(list), eval_list(list, env))
    },
    Types.Vector(vec) => {
      Result.map((vec) => Types.Vector(vec), eval_list(vec, env))
    },
    Types.HashMap(map) => {
      let keys = ImmutableMap.keys(map)
      let vals = ImmutableMap.values(map)
      match (eval_list(vals, env)) {
        Err(err) => Err(err),
        Ok(evaluated) => {
          let entries = List.zip(keys, evaluated)
          Ok(Types.HashMap(ImmutableMap.fromList(entries)))
        }
      }
    },
    ast => Ok(ast),
  }
}

provide let make_env: () -> Types.Env = () => {
  let data = [
    ("+", wrap_op(add)),
    ("-", wrap_op(sub)),
    ("*", wrap_op(mul)),
    ("/", wrap_op(div)),
    ("<", wrap_op(lt)),
    ("<=", wrap_op(le)),
    (">", wrap_op(gt)),
    (">=", wrap_op(ge)),
    ("list", wrap(list)),
    ("list?", wrap_one(is_list)),
    ("empty?", wrap_list(is_empty)),
    ("count", wrap_list(count)),
    ("pr-str", wrap(pr_str)),
    ("str", wrap(str)),
    ("prn", wrap(prn)),
    ("println", wrap(println)),
    ("=", wrap(eq)),
    ("read-string", wrap_str(read_string)),
    ("atom", wrap_one(atom)),
    ("atom?", wrap_one(is_atom)),
    ("deref", wrap_one(deref)),
    ("reset!", wrap_two(reset)),
    ("swap!", wrap(swap)),
    ("cons", wrap_two(cons)),
    ("concat", wrap(concat)),
    ("eval", wrap_one((val, env) => eval(val, env))),
  ]

  { outer: None, data: Map.fromList(data) }
}
