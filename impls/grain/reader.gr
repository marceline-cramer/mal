module Reader

include "list"
include "regex"
include "result"
include "number"
include "option"
include "string"
include "sys/file"
include "./types"

let regex = "[\\s,]*(~@|[\\[\\]{}()'`~^@]|\"(?:\\\\.|[^\\\\\"])*\"?|;.*|[^\\s\\[\\]{}('\"`,;)]*)"
let regex = Result.unwrap(Regex.make(regex))

provide record Reader {
  mut tokens: List<String>
}

provide let peek = (reader) => {
  match (reader.tokens) {
    [current, ..._] => Some(current),
    [] => None
  }
}

provide let next = (reader) => {
  match (reader.tokens) {
    [_, ...rest] => {
      reader.tokens = rest
      peek(reader)
    },
    [] => None
  }
}

let tokenize = (source) => {
  let mut remaining = source
  let mut tokens = []
  let mut err = None

  while(String.length(remaining) > 0) {
    let range = match (Regex.find(regex, remaining)) {
      Some(result) => match (result.groupPosition(0)) {
        Some((0, end)) => {
            let err = "Regex match group 1 is missing"
            let position = result.groupPosition(1)
            Option.toResult(err, position)
        },
        _ => Err("Token reading error")
      },
      _ => Err("Token reading error")
    }

    match (range) {
      Ok((start, end)) => {
        let token = String.slice(start, end, remaining)
        remaining = String.slice(end, String.length(remaining), remaining)
        tokens = match (token) {
          "" => tokens,
          _ when String.startsWith(";", token) => tokens,
          _ => [token, ...tokens]
        }
      },
      Err(match_err) => {
        err = Some(match_err)
        break
      }
    }
  }

  match (err) {
    Some(err) => Err(err),
    None => Ok({ tokens: List.reverse(tokens), })
  }
}

let rec read_list = (reader, term) => {
  let mut list = []
  let mut err = None

  while(true) {
    match (next(reader)) {
      Some(c) when c == term => break,
      Some(_) => match (read_form(reader)) {
        Ok(val) => list = [val, ...list],
        Err(form_err) => {
          err = Some(form_err)
          break
        }
      },
      None => {
        err = Some("unbalanced")
        break
      }
    }
  }

  match (err) {
    Some(err) => Err(err),
    None => Ok(List.reverse(list))
  }
},

read_atom = (reader, tok) => {
  match (tok) {
    "nil" => Ok(Types.Nil),
    "true" => Ok(Types.Bool(true)),
    "false" => Ok(Types.Bool(false)),
    "\"" => Err("unbalanced"), // catch early so that parsing doesn't panic
    _ => match (Number.parseInt(tok, 10)) {
      Ok(number) => Ok(Types.Number(number)),
      Err(_) => match (String.charAt(0, tok)) {
        '"' => {
          let last = String.length(tok) - 1
          if (String.charAt(last, tok) != '"') {
            Err("unbalanced")
          } else {
            let string = String.slice(1, last, tok)
            let string = String.replaceAll("\\\"", "\"", string)
            let string = String.replaceAll("\\n", "\n", string)
            Ok(Types.String(String.slice(1, last, tok)))
          }
        },
        _ => Ok(Types.Symbol(tok)),  
      }
    }
  }
},

read_form = (reader) => {
  match (peek(reader)) {
    Some("(") => Result.map((elems) => Types.List(elems), read_list(reader, ")")),
    Some("[") => Result.map((elems) => Types.Vector(elems), read_list(reader, "]")),
    Some(tok) => read_atom(reader, tok),
    None => Err("end of input")
  }
}

let read_tokens = (reader) => {
  match (read_form(reader)) {
    Err(err) => Err(err),
    Ok(parsed) => match (next(reader)) {
      Some(_) => Err("trailing characters"),
      None => Ok(parsed)
    }
  }
}

provide let read_str = (source) => {
  Result.flatMap(read_tokens, tokenize(source))
}

provide let prompt = () => {
  let prompt = String.encode("user> ", String.UTF8)
  File.fdWrite(File.stdout, prompt)
  let result = File.fdRead(File.stdin, 1024)
  let (line, _len) = Result.unwrap(result)
  let decoded = String.decode(line, String.UTF8)
  let decoded = String.trim(decoded)
  decoded
}
