module Reader

include "immutablemap"
include "list"
include "regex"
include "result"
include "number"
include "option"
include "string"
include "sys/file"
include "./types"

let regex = "[\\s,]*(~@|[\\[\\]{}()'`~^@]|\"(?:\\\\.|[^\\\\\"])*\"?|;.*|[^\\s\\[\\]{}('\"`,;)]*)"
let regex = Result.unwrap(Regex.make(regex))

provide record Reader {
  mut tokens: List<String>
}

provide let peek = (reader) => {
  match (reader.tokens) {
    [current, ..._] => Some(current),
    [] => None
  }
}

provide let next = (reader) => {
  match (reader.tokens) {
    [_, ...rest] => {
      reader.tokens = rest
      peek(reader)
    },
    [] => None
  }
}

provide let list_to_hash_map = (list) => {
  let mut items = []
  let mut remaining = list
  let mut err = None

  while (true) {
    match (remaining) {
      [] => break,
      [Types.String(key), val, ...tail] => {
        items = [(key, val), ...items]
        remaining = tail
      },
      [Types.Keyword(key), val, ...tail] => {
        let key = Types.keyword_prefix ++ key
        items = [(key, val), ...items]
        remaining = tail
      },
      [_, _, ..._] => {
        err = Some("expected string or symbol key")
        break
      },
      _ => {
        err = Some("uneven hash-map entries")
        break
      },
    }
  }

  match (err) {
    Some(err) => Err(err),
    None => Ok(ImmutableMap.fromList(items)),
  }
}

let tokenize = (source) => {
  let mut remaining = source
  let mut tokens = []
  let mut err = None

  while(String.length(remaining) > 0) {
    let range = match (Regex.find(regex, remaining)) {
      Some(result) => match (result.groupPosition(0)) {
        Some((0, end)) => {
            let err = "Regex match group 1 is missing"
            let position = result.groupPosition(1)
            Option.toResult(err, position)
        },
        _ => Err("Token reading error")
      },
      _ => Err("Token reading error")
    }

    match (range) {
      Ok((start, end)) => {
        let token = String.slice(start, end, remaining)
        remaining = String.slice(end, String.length(remaining), remaining)
        tokens = match (token) {
          "" => tokens,
          _ when String.startsWith(";", token) => tokens,
          _ => [token, ...tokens]
        }
      },
      Err(match_err) => {
        err = Some(match_err)
        break
      }
    }
  }

  match (err) {
    Some(err) => Err(err),
    None => Ok({ tokens: List.reverse(tokens), })
  }
}

let rec read_list = (reader, term) => {
  let mut list = []
  let mut err = None

  while(true) {
    match (next(reader)) {
      Some(c) when c == term => break,
      Some(_) => match (read_form(reader)) {
        Ok(val) => list = [val, ...list],
        Err(form_err) => {
          err = Some(form_err)
          break
        }
      },
      None => {
        err = Some("unbalanced")
        break
      }
    }
  }

  match (err) {
    Some(err) => Err(err),
    None => Ok(List.reverse(list))
  }
},

read_atom = (reader, tok) => {
  let quoted = (sym, reader) => {
    next(reader) // progress reader for read_form
    Result.map((ast) => Types.List([Types.Symbol(sym), ast]), read_form(reader))
  }

  match (tok) {
    "nil" => Ok(Types.Nil),
    "true" => Ok(Types.Bool(true)),
    "false" => Ok(Types.Bool(false)),
    "\"" => Err("unbalanced"), // catch early so that parsing doesn't panic
    "@" => quoted("deref", reader),
    "'" => quoted("quote", reader),
    "`" => quoted("quasiquote", reader),
    "~" => quoted("unquote", reader),
    "~@" => quoted("splice-unquote", reader),
    _ => match (Number.parseInt(tok, 10)) {
      Ok(number) => Ok(Types.Number(number)),
      Err(_) => match (String.charAt(0, tok)) {
        '"' => {
          let last = String.length(tok) - 1
          if (String.charAt(last, tok) != '"') {
            Err("unbalanced")
          } else {
            let string = String.slice(1, last, tok)
            let string = String.replaceAll("\\\"", "\"", string)
            let string = String.replaceAll("\\n", "\n", string)
            Ok(Types.String(string))
          }
        },
        ':' => Ok(Types.Keyword(tok)),
        _ => Ok(Types.Symbol(tok)),  
      }
    }
  }
},

read_form = (reader) => {
  match (peek(reader)) {
    Some("(") => Result.map((elems) => Types.List(elems), read_list(reader, ")")),
    Some("[") => Result.map((elems) => Types.Vector(elems), read_list(reader, "]")),
    Some("{") => {
      let list = read_list(reader, "}")
      let map = Result.flatMap(list_to_hash_map, list)
      let val = Result.map((map) => Types.HashMap(map), map)
      val
    },
    Some(tok) => read_atom(reader, tok),
    None => Err("end of input")
  }
}

let read_tokens = (reader) => {
  match (read_form(reader)) {
    Err(err) => Err(err),
    Ok(parsed) => match (next(reader)) {
      Some(_) => Err("trailing characters"),
      None => Ok(parsed)
    }
  }
}

provide let read_str = (source) => {
  Result.flatMap(read_tokens, tokenize(source))
}

provide let prompt = (prompt) => {
  let prompt = String.encode(prompt, String.UTF8)
  File.fdWrite(File.stdout, prompt)
  let result = File.fdRead(File.stdin, 1024)
  let (line, _len) = Result.unwrap(result)
  let decoded = String.decode(line, String.UTF8)
  let decoded = String.trim(decoded)
  decoded
}
