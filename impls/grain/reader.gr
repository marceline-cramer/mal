module Reader

include "list"
include "regex"
include "result"
include "number"
include "option"
include "string"
include "./types"

let regex = "[\\s,]*(~@|[\\[\\]{}()'`~^@]|\"(?:\\\\.|[^\\\\\"])*\"?|;.*|[^\\s\\[\\]{}('\"`,;)]*)"
let regex = Result.unwrap(Regex.make(regex))

provide record Reader {
  mut tokens: List<String>
}

provide let next = (reader) => {
  match (reader.tokens) {
    [next, ...rest] => {
      reader.tokens = rest
      Some(next)
    },
    [] => None
  }
}

provide let peek = (reader) => {
  match (reader.tokens) {
    [current, ..._] => Some(current),
    [] => None
  }
}

let tokenize = (source) => {
  let mut remaining = source
  let mut tokens = []
  let mut err = None

  while(String.length(remaining) > 0) {
    let range = match (Regex.find(regex, remaining)) {
      Some(result) => match (result.groupPosition(0)) {
        Some((0, end)) => {
            let err = "Regex match group 1 is missing"
            let position = result.groupPosition(1)
            Option.toResult(err, position)
        },
        _ => Err("Token reading error")
      },
      _ => Err("Token reading error")
    }

    match (range) {
      Ok((start, end)) => {
        let token = String.slice(start, end, remaining)
        remaining = String.slice(end, String.length(remaining), remaining)
        tokens = [token, ...tokens]
      },
      Err(match_err) => {
        err = Some(match_err)
        break
      }
    }
  }

  match (err) {
    Some(err) => Err(err),
    None => Ok({ tokens: List.reverse(tokens), })
  }
}

let rec read_list = (reader) => {
  let mut list = []
  let mut err = None

  while(true) {
    match (next(reader)) {
      Some(")") => break,
      Some(_) => match (read_form(reader)) {
        Ok(val) => list = [val, ...list],
        Err(form_err) => {
          err = Some(form_err)
          break
        }
      },
      None => {
        err = Some("Unexpected EOF while parsing list")
        break
      }
    }
  }

  match (err) {
    Some(err) => Err(err),
    None => Ok(Types.List(list))
  }
},

read_atom = (reader, tok) => {
  match (Number.parseInt(tok, 10)) {
    Ok(number) => Ok(Types.Number(number)),
    Err(_) => Ok(Types.Symbol(tok)),
  }
},

read_form = (reader) => {
  match (peek(reader)) {
    Some("(") => read_list(reader),
    Some(tok) => read_atom(reader, tok),
    None => Err("Unexpected EOF")
  }
}

provide let read_str = (source) => {
  Result.flatMap(read_form, tokenize(source))
}
